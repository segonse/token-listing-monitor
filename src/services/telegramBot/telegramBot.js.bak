const { Telegraf, Markup } = require("telegraf");
require("dotenv").config();
const db = require("../../config/database");

class TelegramBot {
  constructor() {
    const botToken = process.env.TELEGRAM_BOT_TOKEN;

    if (!botToken) {
      console.error("é”™è¯¯: æœªè®¾ç½®TELEGRAM_BOT_TOKENç¯å¢ƒå˜é‡");
      return;
    }

    this.bot = new Telegraf(botToken);
    this.setupCommands();
    this.setupActions();
  }

  setupCommands() {
    // å¤„ç†/startå‘½ä»¤
    this.bot.command("start", async (ctx) => {
      const telegramChatId = ctx.chat.id.toString();
      const telegramUsername = ctx.from.username || "";

      // è®°å½•ç”¨æˆ·ä¿¡æ¯ï¼Œä½†æš‚ä¸åˆ›å»ºè®¢é˜…
      try {
        // æ£€æŸ¥ç”¨æˆ·æ˜¯å¦å·²å­˜åœ¨
        const [existingUsers] = await db.query(
          "SELECT * FROM users WHERE user_id = ?",
          [`tg_${telegramChatId}`]
        );

        if (existingUsers.length === 0) {
          // åˆ›å»ºæ–°ç”¨æˆ·
          await db.query(
            "INSERT INTO users (user_id, telegram_id, telegram_username) VALUES (?, ?, ?)",
            [`tg_${telegramChatId}`, telegramChatId, telegramUsername]
          );

          console.log(`æ–°Telegramç”¨æˆ·å·²åˆ›å»º: tg_${telegramChatId}`);
        } else {
          // æ›´æ–°ç°æœ‰ç”¨æˆ·çš„Telegramä¿¡æ¯
          await db.query(
            "UPDATE users SET telegram_id = ?, telegram_username = ? WHERE user_id = ?",
            [telegramChatId, telegramUsername, `tg_${telegramChatId}`]
          );

          console.log(`å·²æ›´æ–°Telegramç”¨æˆ·: tg_${telegramChatId}`);
        }
      } catch (error) {
        console.error("åˆ›å»º/æ›´æ–°Telegramç”¨æˆ·å¤±è´¥:", error);
      }

      return ctx.reply(
        "æ¬¢è¿ä½¿ç”¨ä»£å¸ç›‘æ§æœºå™¨äººï¼è¯·é€‰æ‹©ä»¥ä¸‹åŠŸèƒ½ï¼š",
        this.getMainMenu()
      );
    });

    // å¤„ç†/helpå‘½ä»¤
    this.bot.command("help", (ctx) => {
      return ctx.reply(
        "å¯ç”¨å‘½ä»¤:\n" +
          "/start - æ˜¾ç¤ºä¸»èœå•\n" +
          "/help - æ˜¾ç¤ºå¸®åŠ©ä¿¡æ¯\n" +
          "/status - æŸ¥çœ‹ç³»ç»ŸçŠ¶æ€\n" +
          "/exchanges - æŸ¥çœ‹æ”¯æŒçš„äº¤æ˜“æ‰€\n" +
          "æ‚¨ä¹Ÿå¯ä»¥ç‚¹å‡»èœå•æŒ‰é’®ä½¿ç”¨æ›´å¤šåŠŸèƒ½"
      );
    });

    // å¤„ç†/statuså‘½ä»¤
    this.bot.command("status", async (ctx) => {
      try {
        // è·å–ç”¨æˆ·ä¿¡æ¯
        const telegramChatId = ctx.chat.id.toString();
        const userId = `tg_${telegramChatId}`;

        const [users] = await db.query(
          "SELECT * FROM users WHERE user_id = ?",
          [userId]
        );

        if (users.length === 0) {
          return ctx.reply("æ‚¨å°šæœªæ³¨å†Œï¼Œè¯·å‘é€ /start å¼€å§‹ä½¿ç”¨");
        }

        const userInfo = users[0];

        // è·å–è®¢é˜…ä¿¡æ¯
        const [subscriptions] = await db.query(
          `SELECT * FROM user_subscriptions WHERE user_id = ?`,
          [userInfo.id]
        );

        // è·å–ç³»ç»Ÿç»Ÿè®¡æ•°æ®
        const [announcementCount] = await db.query(
          "SELECT COUNT(*) as count FROM announcements"
        );

        let statusMessage = "<b>ğŸ“Š ç³»ç»ŸçŠ¶æ€</b>\n\n";
        statusMessage += `<b>ç”¨æˆ·ID:</b> ${userId}\n`;
        statusMessage += `<b>å·²æ³¨å†Œ:</b> ${new Date(
          userInfo.created_at
        ).toLocaleString("zh-CN")}\n`;
        statusMessage += `<b>è®¢é˜…æ•°é‡:</b> ${subscriptions.length}\n`;
        statusMessage += `<b>ç³»ç»Ÿå…¬å‘Šæ€»æ•°:</b> ${announcementCount[0].count}\n`;

        return ctx.reply(statusMessage, { parse_mode: "HTML" });
      } catch (error) {
        console.error("è·å–çŠ¶æ€å¤±è´¥:", error);
        return ctx.reply("è·å–çŠ¶æ€ä¿¡æ¯å¤±è´¥");
      }
    });

    // å¤„ç†/exchangeså‘½ä»¤
    this.bot.command("exchanges", async (ctx) => {
      try {
        const exchanges = await this.getExchangesList();
        let message = "æ”¯æŒçš„äº¤æ˜“æ‰€åˆ—è¡¨:\n";

        exchanges.forEach((exchange) => {
          message += `- ${exchange}\n`;
        });

        return ctx.reply(
          message,
          Markup.inlineKeyboard([
            [Markup.button.callback("æŸ¥è¯¢å…¬å‘Š", "check_history_announcements")],
          ])
        );
      } catch (error) {
        console.error("è·å–äº¤æ˜“æ‰€åˆ—è¡¨å¤±è´¥:", error);
        return ctx.reply("è·å–äº¤æ˜“æ‰€åˆ—è¡¨å¤±è´¥ï¼Œè¯·ç¨åå†è¯•");
      }
    });
  }

  setupActions() {
    // è®¢é˜…å…¬å‘Šæ¨é€
    this.bot.action("subscribe_announcements", async (ctx) => {
      const telegramChatId = ctx.chat.id.toString();
      const userId = `tg_${telegramChatId}`;

      try {
        // è·å–ç”¨æˆ·ID
        const [users] = await db.query(
          "SELECT id FROM users WHERE user_id = ?",
          [userId]
        );

        if (users.length === 0) {
          return ctx.reply("ç”¨æˆ·ä¸å­˜åœ¨ï¼Œè¯·é‡æ–°å‘é€ /start å‘½ä»¤");
        }

        const userDbId = users[0].id;

        // åˆ›å»ºé»˜è®¤è®¢é˜…ï¼ˆæ‰€æœ‰äº¤æ˜“æ‰€ï¼Œæ‰€æœ‰ç±»å‹ï¼‰
        await db.query(
          `INSERT IGNORE INTO user_subscriptions 
           (user_id, exchange, token_name, project_name, announcement_type)
           VALUES (?, 'all', 'all', 'all', 'all')`,
          [userDbId]
        );

        await ctx.answerCbQuery("è®¢é˜…æˆåŠŸï¼");
        return ctx.reply(
          "æ‚¨å·²æˆåŠŸè®¢é˜…æ‰€æœ‰äº¤æ˜“æ‰€çš„æ‰€æœ‰ç±»å‹ï¼ˆé™¤æœªåˆ†ç±»ï¼‰çš„å…¬å‘Šæ¨é€ï¼æ¯å½“æœ‰æ–°å…¬å‘Šå‘å¸ƒæ—¶ï¼Œæ‚¨å°†æ”¶åˆ°é€šçŸ¥ã€‚"
        );
      } catch (error) {
        console.error("åˆ›å»ºè®¢é˜…å¤±è´¥:", error);
        await ctx.answerCbQuery("è®¢é˜…å¤±è´¥");
        return ctx.reply("è®¢é˜…å¤±è´¥ï¼Œè¯·ç¨åå†è¯•");
      }
    });

    // æŸ¥è¯¢å†å²å…¬å‘Š
    this.bot.action("check_history_announcements", async (ctx) => {
      try {
        await ctx.answerCbQuery();

        // åŠ¨æ€è·å–äº¤æ˜“æ‰€åˆ—è¡¨
        const exchanges = await this.getExchangesList();

        // æ„å»ºåŠ¨æ€é”®ç›˜
        const buttons = [];
        const maxPerRow = 2; // æ¯è¡Œä¸¤ä¸ªæŒ‰é’®

        for (let i = 0; i < exchanges.length; i += maxPerRow) {
          const row = [];
          for (let j = 0; j < maxPerRow && i + j < exchanges.length; j++) {
            const exchange = exchanges[i + j];
            row.push(
              Markup.button.callback(
                exchange,
                `check_${exchange.toLowerCase()}`
              )
            );
          }
          buttons.push(row);
        }

        // æ·»åŠ æœ€åä¸€è¡Œ
        buttons.push([
          Markup.button.callback("æŸ¥çœ‹æ‰€æœ‰äº¤æ˜“æ‰€", "check_all_exchanges"),
          Markup.button.callback("è¿”å›", "back_to_main"),
        ]);

        return ctx.reply(
          "è¯·é€‰æ‹©è¦æŸ¥è¯¢çš„äº¤æ˜“æ‰€:",
          Markup.inlineKeyboard(buttons)
        );
      } catch (error) {
        console.error("ç”Ÿæˆäº¤æ˜“æ‰€èœå•å¤±è´¥:", error);
        return ctx.reply("ç”Ÿæˆèœå•å¤±è´¥ï¼Œè¯·ç¨åå†è¯•");
      }
    });

    // æ·»åŠ äº¤æ˜“æ‰€é€‰æ‹©çš„å¤„ç†
    this.bot.action(/check_(.+)/, async (ctx) => {
      const exchange = ctx.match[1];
      let exchangeName = "æ‰€æœ‰äº¤æ˜“æ‰€";

      if (exchange !== "all_exchanges") {
        exchangeName = exchange.charAt(0).toUpperCase() + exchange.slice(1);
      }

      await ctx.answerCbQuery();

      try {
        // åŠ¨æ€è·å–å…¬å‘Šç±»å‹
        const types = await this.getAnnouncementTypes();

        // æ„å»ºåŠ¨æ€é”®ç›˜
        const buttons = [];
        const maxPerRow = 2; // æ¯è¡Œä¸¤ä¸ªæŒ‰é’®

        for (let i = 0; i < types.length; i += maxPerRow) {
          const row = [];
          for (let j = 0; j < maxPerRow && i + j < types.length; j++) {
            const type = types[i + j];
            row.push(Markup.button.callback(type, `type_${exchange}_${type}`));
          }
          buttons.push(row);
        }

        // æ·»åŠ æœ€åä¸€è¡Œ
        buttons.push([
          Markup.button.callback("æ‰€æœ‰ç±»å‹", `type_${exchange}_all`),
          Markup.button.callback("è¿”å›", "check_history_announcements"),
        ]);

        return ctx.reply(
          `è¯·é€‰æ‹©${exchangeName}çš„å…¬å‘Šç±»å‹:`,
          Markup.inlineKeyboard(buttons)
        );
      } catch (error) {
        console.error("ç”Ÿæˆå…¬å‘Šç±»å‹èœå•å¤±è´¥:", error);
        return ctx.reply("ç”Ÿæˆèœå•å¤±è´¥ï¼Œè¯·ç¨åå†è¯•");
      }
    });

    // æ·»åŠ å…¬å‘Šç±»å‹é€‰æ‹©çš„å¤„ç†
    this.bot.action(/type_(.+)_(.+)/, async (ctx) => {
      const exchange = ctx.match[1];
      const type = ctx.match[2];

      // å­˜å‚¨ç”¨æˆ·é€‰æ‹©ï¼Œç”¨äºåç»­æŸ¥è¯¢
      const chatId = ctx.chat.id.toString();
      if (!this.userSelections) this.userSelections = {};
      this.userSelections[chatId] = {
        exchange,
        type,
      };

      await ctx.answerCbQuery();

      // è¯¢é—®æ˜¯å¦éœ€è¦æŒ‰ä»£å¸åç§°ç­›é€‰
      return ctx.reply(
        "æ‚¨æ˜¯å¦éœ€è¦æŒ‰ä»£å¸åç§°ç­›é€‰?",
        Markup.inlineKeyboard([
          [
            Markup.button.callback(
              "æ˜¯ï¼Œè¾“å…¥ä»£å¸åç§°",
              `filter_token_${exchange}_${type}`
            ),
          ],
          [
            Markup.button.callback(
              "å¦ï¼Œç»§ç»­æŸ¥è¯¢",
              `select_limit_${exchange}_${type}`
            ),
          ],
        ])
      );
    });

    // å¤„ç†ä»£å¸åç§°ç­›é€‰é€‰æ‹©
    this.bot.action(/filter_token_(.+)_(.+)/, (ctx) => {
      const exchange = ctx.match[1];
      const type = ctx.match[2];
      const chatId = ctx.chat.id.toString();

      // æ›´æ–°ç”¨æˆ·çŠ¶æ€
      if (!this.userStates) this.userStates = {};
      this.userStates[chatId] = `waiting_token_${exchange}_${type}`;

      ctx.answerCbQuery();
      return ctx.reply("è¯·è¾“å…¥è¦ç­›é€‰çš„ä»£å¸åç§°æˆ–é¡¹ç›®åç§°:");
    });

    // å¤„ç†è¾“å…¥çš„ä»£å¸åç§°
    this.bot.on("text", async (ctx) => {
      const chatId = ctx.chat.id.toString();
      const text = ctx.message.text;

      // æ£€æŸ¥æ˜¯å¦åœ¨ç­‰å¾…è¾“å…¥ä»£å¸åç§°
      if (
        this.userStates &&
        this.userStates[chatId] &&
        this.userStates[chatId].startsWith("waiting_token_")
      ) {
        const params = this.userStates[chatId].split("_");
        const exchange = params[2];
        const type = params[3];

        // ä¿å­˜ç”¨æˆ·è¾“å…¥çš„ä»£å¸/é¡¹ç›®åç§°
        if (!this.userSelections) this.userSelections = {};
        if (!this.userSelections[chatId]) this.userSelections[chatId] = {};

        this.userSelections[chatId].tokenOrProject = text;

        // æ¸…é™¤çŠ¶æ€
        delete this.userStates[chatId];

        // ç»§ç»­è¯¢é—®ç»“æœæ•°é‡
        return ctx.reply(
          `æ‚¨è¦æŸ¥çœ‹å¤šå°‘æ¡ç»“æœ?`,
          Markup.inlineKeyboard([
            [
              Markup.button.callback(
                "1æ¡",
                `execute_query_${exchange}_${type}_1`
              ),
              Markup.button.callback(
                "5æ¡",
                `execute_query_${exchange}_${type}_5`
              ),
            ],
            [
              Markup.button.callback(
                "10æ¡",
                `execute_query_${exchange}_${type}_10`
              ),
              Markup.button.callback(
                "20æ¡",
                `execute_query_${exchange}_${type}_20`
              ),
            ],
          ])
        );
      }

      // å…¶ä»–æ–‡æœ¬æ¶ˆæ¯å¤„ç†...
    });

    // å¤„ç†ç›´æ¥é€‰æ‹©ç»“æœæ•°é‡ï¼ˆä¸ç­›é€‰ä»£å¸ï¼‰
    this.bot.action(/select_limit_(.+)_(.+)/, (ctx) => {
      const exchange = ctx.match[1];
      const type = ctx.match[2];

      ctx.answerCbQuery();
      return ctx.reply(
        `æ‚¨è¦æŸ¥çœ‹å¤šå°‘æ¡ç»“æœ?`,
        Markup.inlineKeyboard([
          [
            Markup.button.callback(
              "1æ¡",
              `execute_query_${exchange}_${type}_1`
            ),
            Markup.button.callback(
              "5æ¡",
              `execute_query_${exchange}_${type}_5`
            ),
          ],
          [
            Markup.button.callback(
              "10æ¡",
              `execute_query_${exchange}_${type}_10`
            ),
            Markup.button.callback(
              "20æ¡",
              `execute_query_${exchange}_${type}_20`
            ),
          ],
        ])
      );
    });

    // æ‰§è¡ŒæŸ¥è¯¢
    this.bot.action(/execute_query_(.+)_(.+)_(\d+)/, async (ctx) => {
      const exchange = ctx.match[1];
      const type = ctx.match[2];
      const limit = parseInt(ctx.match[3]);
      const chatId = ctx.chat.id.toString();

      await ctx.answerCbQuery();
      await ctx.reply("æ­£åœ¨æŸ¥è¯¢ï¼Œè¯·ç¨å€™...");

      try {
        // å‡†å¤‡æŸ¥è¯¢å‚æ•°
        const exchangeParam = exchange === "all_exchanges" ? "all" : [exchange];
        const typeParam = type === "all" ? "all" : [type];

        let tokenName = null;
        let projectName = null;

        // æ£€æŸ¥æ˜¯å¦æœ‰ä»£å¸/é¡¹ç›®ç­›é€‰
        if (
          this.userSelections &&
          this.userSelections[chatId] &&
          this.userSelections[chatId].tokenOrProject
        ) {
          // è¿™é‡Œç®€å•å¤„ç†ï¼ŒåŒæ—¶ä½œä¸ºä»£å¸åå’Œé¡¹ç›®åå°è¯•æŸ¥è¯¢
          tokenName = this.userSelections[chatId].tokenOrProject;
          projectName = this.userSelections[chatId].tokenOrProject;
        }

        // è°ƒç”¨APIè·å–å…¬å‘Š
        const Announcement = require("../../models/Announcement");
        const announcements = await Announcement.getFilteredAnnouncements({
          exchanges: exchangeParam,
          types: typeParam,
          tokenName,
          projectName,
          limit,
        });

        // æ¸…é™¤ç”¨æˆ·é€‰æ‹©
        if (this.userSelections && this.userSelections[chatId]) {
          delete this.userSelections[chatId];
        }

        // å¤„ç†æŸ¥è¯¢ç»“æœ
        if (announcements.length > 0) {
          for (const announcement of announcements) {
            // å°†æ¯ä¸ªå…¬å‘Šä½œä¸ºå•ç‹¬çš„æ¶ˆæ¯å‘é€ï¼Œé¿å…æ¶ˆæ¯è¿‡é•¿
            const message = this.formatAnnouncementMessage(announcement);
            await ctx.reply(message, {
              parse_mode: "HTML",
              disable_web_page_preview: false,
            });

            // é¿å…å‘é€è¿‡å¿«è§¦å‘Telegramé™æµ
            await new Promise((resolve) => setTimeout(resolve, 300));
          }

          await ctx.reply(
            "ä»¥ä¸Šæ˜¯æŸ¥è¯¢åˆ°çš„æœ€æ–°å…¬å‘Šï¼Œå¦‚éœ€æŸ¥çœ‹æ›´å¤šï¼Œè¯·ç‚¹å‡»ä¸‹æ–¹æŒ‰é’®ï¼š",
            Markup.inlineKeyboard([
              [
                Markup.button.callback(
                  "è¿”å›äº¤æ˜“æ‰€é€‰æ‹©",
                  "check_history_announcements"
                ),
              ],
              [Markup.button.callback("è¿”å›ä¸»èœå•", "back_to_main")],
            ])
          );
        } else {
          await ctx.reply(
            "æœªæŸ¥è¯¢åˆ°ç¬¦åˆæ¡ä»¶çš„å…¬å‘Š",
            Markup.inlineKeyboard([
              [
                Markup.button.callback(
                  "è¿”å›äº¤æ˜“æ‰€é€‰æ‹©",
                  "check_history_announcements"
                ),
              ],
              [Markup.button.callback("è¿”å›ä¸»èœå•", "back_to_main")],
            ])
          );
        }
      } catch (error) {
        console.error("æŸ¥è¯¢å…¬å‘Šå¤±è´¥:", error);
        await ctx.reply(
          "æŸ¥è¯¢å…¬å‘Šå¤±è´¥ï¼Œè¯·ç¨åå†è¯•",
          Markup.inlineKeyboard([
            [Markup.button.callback("è¿”å›", "check_history_announcements")],
          ])
        );
      }
    });
  }

  getMainMenu() {
    return Markup.inlineKeyboard([
      [Markup.button.callback("ğŸ“¢ è®¢é˜…å…¬å‘Šæ¨é€", "subscribe_announcements")],
      [
        Markup.button.callback(
          "ğŸ” æŸ¥è¯¢å†å²å…¬å‘Š",
          "check_history_announcements"
        ),
      ],
      // å…¶ä»–åŠŸèƒ½æŒ‰é’®...
    ]);
  }

  // å¯åŠ¨æœºå™¨äºº
  launch() {
    if (!this.bot) {
      console.error("æ— æ³•å¯åŠ¨Telegram Bot: é…ç½®ä¸å®Œæ•´");
      return false;
    }

    try {
      this.bot.launch();
      console.log("Telegram Bot å·²å¯åŠ¨");

      // ä¼˜é›…åœ°å¤„ç†åœæ­¢ä¿¡å·
      process.once("SIGINT", () => this.bot.stop("SIGINT"));
      process.once("SIGTERM", () => this.bot.stop("SIGTERM"));

      return true;
    } catch (error) {
      console.error("å¯åŠ¨Telegram Botå¤±è´¥:", error);
      return false;
    }
  }

  // æ·»åŠ æ ¼å¼åŒ–å…¬å‘Šæ¶ˆæ¯çš„æ–¹æ³•
  formatAnnouncementMessage(announcement) {
    const chinaTimeString = announcement.publishTime.toLocaleString("zh-CN", {
      timeZone: "Asia/Shanghai",
      year: "numeric",
      month: "2-digit",
      day: "2-digit",
      hour: "2-digit",
      minute: "2-digit",
      second: "2-digit",
      hour12: false,
    });

    let message = `<b>ğŸ”” ${announcement.exchange}å…¬å‘Š</b>\n\n`;
    message += `<b>ğŸ“Œ ç±»å‹:</b> ${announcement.type}\n`;
    message += `<b>ğŸ“Œ æ ‡é¢˜:</b> ${announcement.title}\n`;
    message += `<b>ğŸ“Œ å‘å¸ƒæ—¶é—´:</b> ${chinaTimeString}\n\n`;

    if (announcement.tokenInfoArray && announcement.tokenInfoArray.length > 0) {
      message += "<b>ğŸ“Œ ä»£å¸ä¿¡æ¯:</b>\n";
      announcement.tokenInfoArray.forEach((token) => {
        if (token.tokenName) message += `   - ä»£å¸: ${token.tokenName}\n`;
        if (token.projectName) message += `   - é¡¹ç›®: ${token.projectName}\n`;
      });
      message += "\n";
    }

    message += `<a href="${announcement.url}">æŸ¥çœ‹è¯¦æƒ…</a>`;

    return message;
  }

  // åœ¨TelegramBotç±»ä¸­æ·»åŠ è·å–äº¤æ˜“æ‰€åˆ—è¡¨çš„æ–¹æ³•
  async getExchangesList() {
    try {
      const [exchanges] = await db.query(
        "SELECT DISTINCT exchange FROM announcements ORDER BY exchange"
      );
      return exchanges.map((e) => e.exchange);
    } catch (error) {
      console.error("è·å–äº¤æ˜“æ‰€åˆ—è¡¨å¤±è´¥:", error);
      return ["Binance"]; // é»˜è®¤å€¼ï¼Œé¿å…å®Œå…¨å¤±è´¥
    }
  }

  // è·å–å…¬å‘Šç±»å‹åˆ—è¡¨çš„æ–¹æ³•
  async getAnnouncementTypes() {
    try {
      const [types] = await db.query(
        "SELECT DISTINCT type FROM announcements WHERE type != 'æœªåˆ†ç±»' ORDER BY type"
      );
      return types.map((t) => t.type);
    } catch (error) {
      console.error("è·å–å…¬å‘Šç±»å‹åˆ—è¡¨å¤±è´¥:", error);
      return ["ä¸Šæ–°", "ç›˜å‰", "åˆ›æ–°"]; // é»˜è®¤å€¼
    }
  }
}

module.exports = new TelegramBot();
